package processm.core.models.bpmn

import org.junit.jupiter.api.DynamicTest
import org.junit.jupiter.api.TestFactory
import processm.core.models.bpmn.jaxb.TDefinitions
import java.io.ByteArrayInputStream
import java.io.ByteArrayOutputStream
import java.io.File
import java.lang.reflect.Field
import javax.xml.bind.JAXBElement
import javax.xml.bind.annotation.XmlAttribute
import javax.xml.bind.annotation.XmlElement
import javax.xml.stream.XMLStreamException
import kotlin.test.assertFailsWith
import kotlin.test.assertTrue

class BPMNXMLServiceTest {
    private val invalidEncoding = setOf(
        "/GenMyModel 0.47/C.1.1-roundtrip.bpmn",
        "/GenMyModel 0.47/C.1.1-export.bpmn",
        "/GenMyModel 0.47/C.1.0-export.bpmn",
        "/GenMyModel 0.47/C.1.0-roundtrip.bpmn",
        "/ARIS Architect 10.0.10/C.1.1-roundtrip.bpmn",
        "/ARIS Architect 10.0.10/C.1.1-export.bpmn",
        "/ARIS Architect 10.0.10/C.1.0-export.bpmn",
        "/ARIS Architect 10.0.10/C.1.0-roundtrip.bpmn"
    )

    private val nonStrict = setOf(
        "/ModelFoundry 1.1.1/C.1.1-roundtrip.bpmn",
        "/ModelFoundry 1.1.1/A.2.1-roundtrip.bpmn",
        "/ModelFoundry 1.1.1/C.3.0-roundtrip.bpmn",
        "/ModelFoundry 1.1.1/C.1.0-roundtrip.bpmn",
        "/iGrafx FlowCharter 2013 15.1.1.1580/B.2.0-export.bpmn",
        "/iGrafx Process 2013 for Six Sigma 15.0.4.1565/B.2.0-export.bpmn"
    )

    /**
     * These files behave strangely - their deserialization, serialization and deserialization again does not lead to the same results.
     * They mostly fail in comparison with something being null, while the other thing is not null
     */
    private val nonIdempotent = setOf(
        "/BPMN+ Composer V.10.4/C.4.0-export.bpmn",
        "/BPMN+ Composer V.10.4/B.2.0-export.bpmn",
        "/W4 BPMN+ Composer V.9.4/B.2.0-export.bpmn",
        "/Aeneis 5.7.89.2400/C.1.0-roundtrip.bpmn",
        "/Aeneis 5.7.89.2400/A.4.1-roundtrip.bpmn",
        "/MID Innovator 12.3.1.20212/C.1.1-export.bpmn",
        "/MID Innovator 12.3.1.20212/C.1.1-roundtrip.bpmn",
        "/Signavio Process Editor 10.0.0/B.2.0-roundtrip.bpmn",
        "/ModelFoundry 1.1.1/B.2.0-roundtrip.bpmn",
        "/ARIS Architect 9.8.3/Signavio 9.7.0/B.2.0-export-rountrip.bpmn",
        "/bpmn.io (Cawemo, Camunda Modeler) 1.12.0/A.1.2-roundtrip.bpmn"
    )

    private val base = "src/test/resources/bpmn-miwg-test-suite"
    private val files = File(base)
        .walk()
        .filter { it.extension.toLowerCase() == "bpmn" }
        .iterator()
        .asSequence()
    private val strictFiles = files.filter { !(nonStrict + invalidEncoding).any { p -> it.path.endsWith(p) } }
    private val idempotentFiles = strictFiles.filter { !nonIdempotent.any { p -> it.path.endsWith(p) } }

    @TestFactory
    fun load(): Iterable<DynamicTest> {
        return files
            .filter { !invalidEncoding.any { p -> it.path.endsWith(p) } }
            .map { DynamicTest.dynamicTest(it.path.replace(base, "")) { BPMNXMLService.load(it.inputStream()) } }
            .toList()
    }

    @TestFactory
    fun loadInvalidEncoding(): Iterable<DynamicTest> {
        return files
            .filter { invalidEncoding.any { p -> it.path.endsWith(p) } }
            .map {
                DynamicTest.dynamicTest(it.path.replace(base, ""))
                { assertFailsWith<XMLStreamException> { BPMNXMLService.load(it.inputStream()) } }
            }.toList()
    }

    @TestFactory
    fun loadStrict(): Iterable<DynamicTest> {
        return strictFiles
            .map {
                DynamicTest.dynamicTest(it.path.replace(base, ""))
                { BPMNXMLService.loadStrict(it.inputStream()) }
            }.toList()
    }

    @TestFactory
    fun loadAndSave(): Iterable<DynamicTest> {
        return idempotentFiles
            .map {
                DynamicTest.dynamicTest(it.path.replace(base, "")) {
                    val out = ByteArrayOutputStream()
                    val a = BPMNXMLService.loadStrict(it.inputStream())
                    BPMNXMLService.save(a, out)
                    val b = BPMNXMLService.loadStrict(ByteArrayInputStream(out.toByteArray()))
                    /*
                    I have no better how to perform any sort of verification:
                    * XMLUnit is too picky
                    * Equals generated by Equals or Simple Equals plugins of jaxb2 basic on unmarshalled objects frequently yields StackOverflowError
                    * In general, XMLs are not stable, e.g., because they serialize Doubles to string
                     */
                    assertTrue { JaxbRecursiveComparer()(a, b) }
                }
            }.toList()
    }
}