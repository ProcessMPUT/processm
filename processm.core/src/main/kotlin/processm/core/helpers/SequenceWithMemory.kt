package processm.core.helpers

/**
 * A sequence with partial materialization
 *
 * Every element generated by the underlying iterable (e.g., Sequence) is stored, so to avoid regenerating it.
 * Useful if generating elements is pricey. Intended usage with [withMemory] and [asList] extension functions.
 */
internal class SequenceWithMemory<T>(private val iterator: Iterator<T>) : Sequence<T>, AbstractList<T>() {
    constructor(base: Sequence<T>) : this(base.iterator())

    private val memory = ArrayList<T>()

    override val size: Int
        get() {
            readToEnd()
            return memory.size
        }

    private fun readNext(): T = iterator.next().apply(memory::add)
    private fun readToEnd() {
        while (iterator.hasNext())
            readNext()
    }

    override fun isEmpty(): Boolean = memory.isEmpty() && !iterator.hasNext()

    override fun get(index: Int): T {
        while (memory.size <= index && iterator.hasNext())
            readNext()

        if (index < memory.size)
            return memory[index]

        throw IndexOutOfBoundsException(index)
    }

    override fun iterator(): Iterator<T> = object : Iterator<T> {
        private val memIt = memory.listIterator()
        override fun hasNext(): Boolean = memIt.hasNext() || iterator.hasNext()

        override fun next(): T =
            if (memIt.hasNext())
                memIt.next()
            else
                iterator.next().apply(memIt::add)
    }
}

/**
 * Adds partial materialization to the sequence. Use sparingly.
 */
fun <T> Sequence<T>.withMemory(): Sequence<T> =
    if (this is SequenceWithMemory<T>) this else SequenceWithMemory(this.iterator())

/**
 * Wraps this collection into the [List] interface. The underlying sequence is guaranteed to be read exactly once.
 * The underlying sequence is read lazily and only if the requested operation needs more data.
 *
 * This method is a lightweight equivalent of `Sequence<T>.toList()`.
 */
fun <T> Sequence<T>.asList(): List<T> = SequenceWithMemory(this.iterator())

/**
 * Wraps this collection into the [List] interface. The underlying collection is guaranteed to be read exactly once.
 * The underlying sequence is read lazily and only if the requested operation needs more data.
 *
 * This method is a lightweight equivalent of `Iterable<T>.toList()`.
 */
fun <T> Iterable<T>.asList(): List<T> = if (this is List<T>) this else SequenceWithMemory(this.iterator())
