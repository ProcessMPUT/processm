package processm.core.querylanguage

import org.antlr.v4.runtime.RecognitionException
import processm.helpers.AbstractLocalizedException
import processm.logging.logger
import java.util.*

internal class ProxyRecognitionException(
    val problem: PQLParserError.Problem,
    val offendingToken: TokenSequence,
    val expectedTokens: Collection<String>?,
) : RecognitionException(null, null, null)


enum class TokenSequenceType {
    Unknown,
    EOF,
    Normal
}

data class TokenSequence private constructor(val type: TokenSequenceType, val value: String?) {

    companion object {
        val Unknown = TokenSequence(TokenSequenceType.Unknown, null)
        val EOF = TokenSequence(TokenSequenceType.EOF, null)

        private fun String.escapeWS() = replace("\n", "\\n").replace("\r", "\\r").replace("\t", "\\t")
    }

    constructor(value: String) : this(TokenSequenceType.Normal, value.escapeWS())

    init {
        assert((type == TokenSequenceType.Normal) == (value !== null))
    }

    override fun toString(): String = when (type) {
        TokenSequenceType.Unknown -> "<unknown>"
        TokenSequenceType.EOF -> "<EOF>"
        TokenSequenceType.Normal -> "'$value'"
    }
}

class PQLParserError(
    val problem: Problem,
    val line: Int,
    val charPositionInLine: Int,
    val offendingToken: TokenSequence,
    val expectedTokens: Collection<String>?,
    originalMessage: String?,
    val baseException: RecognitionException?
) : AbstractLocalizedException(
    "Line $line position $charPositionInLine: $originalMessage (offendingToken='$offendingToken' expectedTokens='$expectedTokens' problem=$problem)"
) {
    override fun localizedMessage(locale: Locale): String = try {
        val prefixFormatString = getFormatString(locale, "PQLErrorPrefix")
        val formatString = getFormatString(locale, problem.toString())
        String.format(locale, prefixFormatString, line, charPositionInLine) +
                ": " +
                String.format(locale, formatString, offendingToken, expectedTokens?.joinToString())
    } catch (e: Exception) {
        logger().error("An exception was thrown while preparing localized exception", e)
        message ?: problem.toString()
    }

    enum class Problem {
        Unknown,

        /**
         * @see org.antlr.v4.runtime.FailedPredicateException
         */
        FailedPredicate,

        /**
         * @see org.antlr.v4.runtime.InputMismatchException
         */
        InputMismatch,

        /**
         * @see org.antlr.v4.runtime.LexerNoViableAltException
         */
        LexerNoViableAlt,

        /**
         * @see org.antlr.v4.runtime.NoViableAltException
         */
        NoViableAlt,


        /**
         * Generated by [Query.ErrorStrategy.reportMissingToken]
         */
        MissingToken,

        /**
         * Generated by [Query.ErrorStrategy.reportUnwantedToken]
         */
        UnwantedToken,
    }
}

class PQLSyntaxError(
    val problem: Problem,
    val line: Int,
    val charPositionInLine: Int,
    vararg val args: Any
) : AbstractLocalizedException(
    "Line $line position $charPositionInLine: $problem $args"
) {
    override fun localizedMessage(locale: Locale): String = try {
        val prefixFormatString = getFormatString(locale, "PQLErrorPrefix")
        val formatString = getFormatString(locale, problem.toString())
        String.format(locale, prefixFormatString, line, charPositionInLine) +
                ": " +
                String.format(locale, formatString, *args)
    } catch (e: Exception) {
        logger().error("An exception was thrown while preparing localized exception", e)
        message ?: problem.toString()
    }

    enum class Problem {
        //The aggregation function call is not supported in the where clause.
        AggregationFunctionInWhere,

        //The use of the classifier is not supported in the where clause.
        ClassifierInWhere,

        //A duplicate limit overrides the previous value.
        DuplicateLimit,

        //A duplicate offset overrides the previous value.
        DuplicateOffset,

        //A value of the $clause must be a positive integer, $number given.
        PositiveIntegerRequired,

        //Dropped the decimal part of $number.
        DecimalPartDropped,

        //Scope is required for the number $number in the $clause clause.
        ScopeRequired,

        //Scope hoisting is not supported in the select and the order by clauses, except in an aggregation function.
        ScopeHoistingInSelectOrOrderBy,

        //Expected ${expression.expectedChildrenTypes[i]} but ${expression.children[i].type} found.
        UnexpectedChild,

        //"Use of the explicit select all clause with the implicit group by clause is meaningless."
        ExplicitSelectAllWithImplicitGroupBy,

        //"Use of an aggregation function without a group by clause requires all attributes on the same and the lower scopes to be aggregated. "
        //                                    + "The attribute(s) ${nonaggregated.joinToString(", ")} is/are not supplied to an aggregation function."
        MissingAttributesInAggregation,

        //"Line ${first.line} position ${first.charPositionInLine}: Use of select all with scope $scope and "
        //                            + "referencing attributes by name on the same scope is meaningless. Attributes "
        //                            + "${(standard + other).joinToString(", ")} are removed from the select clause."
        SelectAllConflictsWithReferencingByName,

        //"Select all clause at scope $_scope is not allowed together with the group by clause at scope $scope."
        MixedScopes,

        //The attribute $it is not included in the group by clause. Such attributes can be used only as an argument of an aggregation function.
        AttributeNotInGroupBy,

        //        "Line ${orderByExpression.line} position ${orderByExpression.charPositionInLine}: Use of the order "
        //        + "by clause with the implicit group by clause is meaningless. The order by clause is removed."
        OrderByClauseRemoved,

        //"Line $line position $charPositionInLine: Use of the classifier $this on the log scope is not allowed."
        ClassifierOnLog,

        //It is not supported to hoist a scope beyond the log scope.
        NoHoistingBeyondLong,

        // Unknown type of attribute $standardName.
        UnknownAttributeType,

        //No such attribute: $attribute. Try using the square-bracket syntax for non-standard attributes.
        NoSuchAttribute,

        //Invalid format of boolean literal: $literal.
        InvalidBoolean,

        //a wrapper for NumberFormatException
        InvalidNumber,

        //Invalid format of datetime literal: $literal.
        InvalidDateTime,

        //Invalid format of UUID literal: $literal.
        InvalidUUID
    }
}
