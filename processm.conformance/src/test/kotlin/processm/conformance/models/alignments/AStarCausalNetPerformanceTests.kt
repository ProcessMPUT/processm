package processm.conformance.models.alignments

import processm.core.log.Helpers
import processm.core.log.XMLXESInputStream
import processm.core.log.hierarchical.HoneyBadgerHierarchicalXESInputStream
import processm.core.log.hierarchical.InMemoryXESProcessing
import processm.core.log.hierarchical.Log
import processm.core.models.causalnet.CausalNet
import processm.core.models.causalnet.DBSerializer
import processm.core.models.causalnet.Node
import processm.core.models.causalnet.causalnet
import processm.core.persistence.connection.DBCache
import processm.helpers.allSubsets
import processm.logging.loggedScope
import java.io.File
import java.util.*
import java.util.zip.GZIPInputStream
import kotlin.test.Ignore
import kotlin.test.Test
import kotlin.test.assertEquals

@Ignore("These tests are intented for manual execution")
class AStarCausalNetPerformanceTests {
    companion object {
        val REPETITIONS = 5
        val totals = LinkedHashMap<String, Long>()

        val dataStoreId = UUID(0x1FFFFFL, System.currentTimeMillis()).toString()

        init {
            DBCache.get(dataStoreId).getConnection().use { connection ->
                connection.autoCommit = false

                connection.createStatement().use { statement ->
                    statement.execute(ClassLoader.getSystemClassLoader().getResource("photo_copier.sql")!!.readText())
                }

                connection.commit()
            }
        }

        /**
         * A c-net generated by some version of Online Miner that causes OutOfMemoryError when calculating alignments
         */
        val cnet = DBSerializer.fetch(DBCache.get(dataStoreId).database, 1)

        @OptIn(InMemoryXESProcessing::class)
        val log =
            HoneyBadgerHierarchicalXESInputStream(XMLXESInputStream(GZIPInputStream(File("../xes-logs/artificial_digital_photo_copier_event_log.xes.gz").inputStream()))).first()
    }


    @OptIn(InMemoryXESProcessing::class)
    @Test
    @Ignore
    fun `artificial_digital_photo_copier_event_log`() = loggedScope { logger ->
        val astar = AStar(cnet)
        var count = 0
        for (trace in log.traces) {
            val start = System.currentTimeMillis()
            val alignment = astar.align(trace)
            val total = System.currentTimeMillis() - start
            logger.info("Calculated alignment $alignment in ${total}ms")
            count += 1
        }
        assertEquals(log.traces.count(), count)
    }

    @Test
    fun `Parallel decisions in loop with many splits C-net non-conforming log`() {
        val activities1 = "ABCDEFGHIJKLM".map { Node(it.toString()) }
        val activities2 = "NOPQRSTUVWXYZ".map { Node(it.toString()) }

        val st = Node("start", isSilent = true)
        val en = Node("end", isSilent = true)

        val loopStart = Node("ls")
        val loopEnd = Node("le")

        val dec1 = Node("d1")
        val dec2 = Node("d2")

        val model = causalnet {
            start = st
            end = en

            st splits loopStart
            st joins loopStart
            loopStart splits dec1 + dec2

            loopStart joins dec1
            for (act1 in activities1) {
                dec1 joins act1
                act1 splits loopEnd
                for (act2 in activities2) {
                    act1 + act2 join loopEnd
                }
            }

            for (act1 in activities1.allSubsets(true).filter { it.size <= 3 }) {
                dec1 splits act1
            }

            loopStart joins dec2
            for (act2 in activities2) {
                dec2 splits act2
                dec2 joins act2
                act2 splits loopEnd
            }

            for (act2 in activities1.allSubsets(true).filter { it.size <= 3 }) {
                dec2 splits act2
            }

            loopEnd splits loopStart
            loopEnd joins loopStart

            loopEnd splits en
            loopEnd joins en
        }

        val log = Helpers.logFromString(
            """
                ls d2 M d1 Z le
                d2 ls d1 Z M le
                ls d1 d2 A N ls le ls d1 C d2 O le
                ls d1 d2 A N ls le ls d1 C d2 O le ls d1 D d2 P le
                ls d1 d2 A N ls le ls d1 C d2 O le ls d1 D D d2 P le
                ls d1 d2 A N ls le ls d1 C d2 O le ls d1 D D d2 P le ls d2 d1 Q le ls d1 d2 F R le
            """
            //  ls d1 d2 A N ls le ls d1 C d2 O le ls d1 D d2 P le ls d2 d1 E Q le ls d1 d2 F R le ls d2 d1 G S le ls d1 H d2 T le ls d1 I d2 U le ls d2 d1 J V le ls d1 d2 K W le ls d1 L d2 X ls le d1 M d2 Y le
        )

        compare(model, log)

    }


    fun compare(net: CausalNet, log: Log) {
        val algorithms = listOf(
            AStar(net)
        )

        // warm up
        for (trace in log.traces) {
            for (algorithm in algorithms) {
                algorithm.align(trace)
            }
        }

        System.gc()

        // actual test
        val times = algorithms.map { algorithm ->
            val start = System.nanoTime()
            repeat(REPETITIONS) {
                for (trace in log.traces) {
                    val alignment = algorithm.align(trace)
                }
            }
            val ret = System.nanoTime() - start
            System.gc()
            ret
        }

        for ((algorithm, time) in algorithms zip times) {
            println(
                String.format(
                    "%-20s: %6dms%s",
                    algorithm::class.simpleName,
                    time / 1000000,
                    if (time == times.minOrNull()) "*" else ""
                )
            )
            totals.compute(algorithm::class.simpleName!!) { _, old ->
                (old ?: 0L) + time
            }
        }
    }
}
